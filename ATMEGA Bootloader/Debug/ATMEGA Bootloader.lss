
ATMEGA Bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006a2  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f6  00800060  000076a2  00000736  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000047  00800156  00800156  0000082c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000082c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000085c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000898  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001080  00000000  00000000  00000918  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007fc  00000000  00000000  00001998  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008dc  00000000  00000000  00002194  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000158  00000000  00000000  00002a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000051d  00000000  00000000  00002bc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000ad2  00000000  00000000  000030e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00003bb7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 31 38 	jmp	0x7062	; 0x7062 <__ctors_end>
    7004:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7008:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    700c:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7010:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7014:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7018:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    701c:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7020:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7024:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7028:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    702c:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7030:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7034:	0c 94 a4 3a 	jmp	0x7548	; 0x7548 <__vector_13>
    7038:	0c 94 d0 3a 	jmp	0x75a0	; 0x75a0 <__vector_14>
    703c:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7040:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7044:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7048:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    704c:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7050:	0c 94 4e 38 	jmp	0x709c	; 0x709c <__bad_interrupt>
    7054:	43 39       	cpi	r20, 0x93	; 147
    7056:	51 39       	cpi	r21, 0x91	; 145
    7058:	6f 39       	cpi	r22, 0x9F	; 159
    705a:	96 39       	cpi	r25, 0x96	; 150
    705c:	be 39       	cpi	r27, 0x9E	; 158
    705e:	12 3a       	cpi	r17, 0xA2	; 162
    7060:	55 3a       	cpi	r21, 0xA5	; 165

00007062 <__ctors_end>:
    7062:	11 24       	eor	r1, r1
    7064:	1f be       	out	0x3f, r1	; 63
    7066:	cf e5       	ldi	r28, 0x5F	; 95
    7068:	d8 e0       	ldi	r29, 0x08	; 8
    706a:	de bf       	out	0x3e, r29	; 62
    706c:	cd bf       	out	0x3d, r28	; 61

0000706e <__do_copy_data>:
    706e:	11 e0       	ldi	r17, 0x01	; 1
    7070:	a0 e6       	ldi	r26, 0x60	; 96
    7072:	b0 e0       	ldi	r27, 0x00	; 0
    7074:	e2 ea       	ldi	r30, 0xA2	; 162
    7076:	f6 e7       	ldi	r31, 0x76	; 118
    7078:	02 c0       	rjmp	.+4      	; 0x707e <__do_copy_data+0x10>
    707a:	05 90       	lpm	r0, Z+
    707c:	0d 92       	st	X+, r0
    707e:	a6 35       	cpi	r26, 0x56	; 86
    7080:	b1 07       	cpc	r27, r17
    7082:	d9 f7       	brne	.-10     	; 0x707a <__do_copy_data+0xc>

00007084 <__do_clear_bss>:
    7084:	21 e0       	ldi	r18, 0x01	; 1
    7086:	a6 e5       	ldi	r26, 0x56	; 86
    7088:	b1 e0       	ldi	r27, 0x01	; 1
    708a:	01 c0       	rjmp	.+2      	; 0x708e <.do_clear_bss_start>

0000708c <.do_clear_bss_loop>:
    708c:	1d 92       	st	X+, r1

0000708e <.do_clear_bss_start>:
    708e:	ad 39       	cpi	r26, 0x9D	; 157
    7090:	b2 07       	cpc	r27, r18
    7092:	e1 f7       	brne	.-8      	; 0x708c <.do_clear_bss_loop>
    7094:	0e 94 bd 38 	call	0x717a	; 0x717a <main>
    7098:	0c 94 4f 3b 	jmp	0x769e	; 0x769e <_exit>

0000709c <__bad_interrupt>:
    709c:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

000070a0 <hex2num>:
	/* Re-enable interrupts (if they were ever enabled). */
	SREG = sreg;
}

static uint16_t hex2num (const uint8_t * ascii, uint8_t num)
{
    70a0:	48 2f       	mov	r20, r24
	uint8_t  i;
	uint16_t val = 0;

	for (i=0; i<num; i++)
    70a2:	e8 2f       	mov	r30, r24
    70a4:	f9 2f       	mov	r31, r25
}

static uint16_t hex2num (const uint8_t * ascii, uint8_t num)
{
	uint8_t  i;
	uint16_t val = 0;
    70a6:	20 e0       	ldi	r18, 0x00	; 0
    70a8:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<num; i++)
    70aa:	1a c0       	rjmp	.+52     	; 0x70e0 <hex2num+0x40>
	{
		uint8_t c = ascii[i];
    70ac:	91 91       	ld	r25, Z+
		
		/* Hex-Ziffer auf ihren Wert abbilden */
		if (c >= '0' && c <= '9')            c -= '0';
    70ae:	80 ed       	ldi	r24, 0xD0	; 208
    70b0:	89 0f       	add	r24, r25
    70b2:	8a 30       	cpi	r24, 0x0A	; 10
    70b4:	60 f0       	brcs	.+24     	; 0x70ce <hex2num+0x2e>
		else if (c >= 'A' && c <= 'F')       c -= 'A' - 10;
    70b6:	8f eb       	ldi	r24, 0xBF	; 191
    70b8:	89 0f       	add	r24, r25
    70ba:	86 30       	cpi	r24, 0x06	; 6
    70bc:	10 f4       	brcc	.+4      	; 0x70c2 <hex2num+0x22>
    70be:	97 53       	subi	r25, 0x37	; 55
    70c0:	07 c0       	rjmp	.+14     	; 0x70d0 <hex2num+0x30>
		else if (c >= 'a' && c <= 'f')       c -= 'a' - 10;
    70c2:	8f e9       	ldi	r24, 0x9F	; 159
    70c4:	89 0f       	add	r24, r25
    70c6:	86 30       	cpi	r24, 0x06	; 6
    70c8:	18 f4       	brcc	.+6      	; 0x70d0 <hex2num+0x30>
    70ca:	97 55       	subi	r25, 0x57	; 87
    70cc:	01 c0       	rjmp	.+2      	; 0x70d0 <hex2num+0x30>
	for (i=0; i<num; i++)
	{
		uint8_t c = ascii[i];
		
		/* Hex-Ziffer auf ihren Wert abbilden */
		if (c >= '0' && c <= '9')            c -= '0';
    70ce:	98 2f       	mov	r25, r24
		else if (c >= 'A' && c <= 'F')       c -= 'A' - 10;
		else if (c >= 'a' && c <= 'f')       c -= 'a' - 10;
		
		val = 16 * val + c;
    70d0:	22 95       	swap	r18
    70d2:	32 95       	swap	r19
    70d4:	30 7f       	andi	r19, 0xF0	; 240
    70d6:	32 27       	eor	r19, r18
    70d8:	20 7f       	andi	r18, 0xF0	; 240
    70da:	32 27       	eor	r19, r18
    70dc:	29 0f       	add	r18, r25
    70de:	31 1d       	adc	r19, r1
static uint16_t hex2num (const uint8_t * ascii, uint8_t num)
{
	uint8_t  i;
	uint16_t val = 0;

	for (i=0; i<num; i++)
    70e0:	8e 2f       	mov	r24, r30
    70e2:	84 1b       	sub	r24, r20
    70e4:	86 17       	cp	r24, r22
    70e6:	10 f3       	brcs	.-60     	; 0x70ac <hex2num+0xc>
		
		val = 16 * val + c;
	}
	
	return val;
}
    70e8:	c9 01       	movw	r24, r18
    70ea:	08 95       	ret

000070ec <program_page>:
#define PARSER_STATE_DATA       4
#define PARSER_STATE_CHECKSUM   5
#define PARSER_STATE_ERROR      6

void program_page (uint32_t page, uint8_t *buf)
{
    70ec:	cf 92       	push	r12
    70ee:	df 92       	push	r13
    70f0:	ef 92       	push	r14
    70f2:	ff 92       	push	r15
    70f4:	cf 93       	push	r28
    70f6:	df 93       	push	r29
    70f8:	6b 01       	movw	r12, r22
    70fa:	7c 01       	movw	r14, r24
	uint16_t i;
	uint8_t sreg;

	/* Disable interrupts */
	sreg = SREG;
    70fc:	6f b7       	in	r22, 0x3f	; 63
	cli();
    70fe:	f8 94       	cli

	eeprom_busy_wait ();
    7100:	e1 99       	sbic	0x1c, 1	; 28
    7102:	fe cf       	rjmp	.-4      	; 0x7100 <program_page+0x14>

	boot_page_erase (page);
    7104:	c6 01       	movw	r24, r12
    7106:	23 e0       	ldi	r18, 0x03	; 3
    7108:	f6 01       	movw	r30, r12
    710a:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    710e:	e8 95       	spm
	boot_spm_busy_wait ();      /* Wait until the memory is erased. */
    7110:	07 b6       	in	r0, 0x37	; 55
    7112:	00 fc       	sbrc	r0, 0
    7114:	fd cf       	rjmp	.-6      	; 0x7110 <program_page+0x24>
    7116:	ea 01       	movw	r28, r20
    7118:	c0 58       	subi	r28, 0x80	; 128
    711a:	df 4f       	sbci	r29, 0xFF	; 255
    711c:	da 01       	movw	r26, r20
	{
		/* Set up little-endian word. */
		uint16_t w = *buf++;
		w += (*buf++) << 8;
		
		boot_page_fill (page + i, w);
    711e:	31 e0       	ldi	r19, 0x01	; 1
    7120:	fc 01       	movw	r30, r24
    7122:	e4 1b       	sub	r30, r20
    7124:	f5 0b       	sbc	r31, r21
    7126:	af 01       	movw	r20, r30
	boot_spm_busy_wait ();      /* Wait until the memory is erased. */

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		/* Set up little-endian word. */
		uint16_t w = *buf++;
    7128:	2c 91       	ld	r18, X
		w += (*buf++) << 8;
		
		boot_page_fill (page + i, w);
    712a:	fa 01       	movw	r30, r20
    712c:	ea 0f       	add	r30, r26
    712e:	fb 1f       	adc	r31, r27
    7130:	11 96       	adiw	r26, 0x01	; 1
    7132:	8c 91       	ld	r24, X
    7134:	11 97       	sbiw	r26, 0x01	; 1
    7136:	90 e0       	ldi	r25, 0x00	; 0
    7138:	98 2f       	mov	r25, r24
    713a:	88 27       	eor	r24, r24
    713c:	82 0f       	add	r24, r18
    713e:	91 1d       	adc	r25, r1
    7140:	0c 01       	movw	r0, r24
    7142:	30 93 57 00 	sts	0x0057, r19	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7146:	e8 95       	spm
    7148:	11 24       	eor	r1, r1
    714a:	12 96       	adiw	r26, 0x02	; 2
	eeprom_busy_wait ();

	boot_page_erase (page);
	boot_spm_busy_wait ();      /* Wait until the memory is erased. */

	for (i=0; i<SPM_PAGESIZE; i+=2)
    714c:	ac 17       	cp	r26, r28
    714e:	bd 07       	cpc	r27, r29
    7150:	59 f7       	brne	.-42     	; 0x7128 <program_page+0x3c>
		w += (*buf++) << 8;
		
		boot_page_fill (page + i, w);
	}

	boot_page_write (page);     /* Store buffer in flash page.		*/
    7152:	85 e0       	ldi	r24, 0x05	; 5
    7154:	f6 01       	movw	r30, r12
    7156:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    715a:	e8 95       	spm
	boot_spm_busy_wait();       /* Wait until the memory is written.*/
    715c:	07 b6       	in	r0, 0x37	; 55
    715e:	00 fc       	sbrc	r0, 0
    7160:	fd cf       	rjmp	.-6      	; 0x715c <program_page+0x70>

	/* Reenable RWW-section again. We need this if we want to jump back */
	/* to the application after bootloading. */
	boot_rww_enable ();
    7162:	81 e1       	ldi	r24, 0x11	; 17
    7164:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7168:	e8 95       	spm

	/* Re-enable interrupts (if they were ever enabled). */
	SREG = sreg;
    716a:	6f bf       	out	0x3f, r22	; 63
}
    716c:	df 91       	pop	r29
    716e:	cf 91       	pop	r28
    7170:	ff 90       	pop	r15
    7172:	ef 90       	pop	r14
    7174:	df 90       	pop	r13
    7176:	cf 90       	pop	r12
    7178:	08 95       	ret

0000717a <main>:
/* Funktionspointer auf 0x0000 */
void (*start)( void ) = (void*)0x0000;


int main()
{
    717a:	cf 93       	push	r28
    717c:	df 93       	push	r29
    717e:	cd b7       	in	r28, 0x3d	; 61
    7180:	de b7       	in	r29, 0x3e	; 62
    7182:	c6 58       	subi	r28, 0x86	; 134
    7184:	d1 09       	sbc	r29, r1
    7186:	0f b6       	in	r0, 0x3f	; 63
    7188:	f8 94       	cli
    718a:	de bf       	out	0x3e, r29	; 62
    718c:	0f be       	out	0x3f, r0	; 63
    718e:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7190:	2f ef       	ldi	r18, 0xFF	; 255
    7192:	89 e6       	ldi	r24, 0x69	; 105
    7194:	98 e1       	ldi	r25, 0x18	; 24
    7196:	21 50       	subi	r18, 0x01	; 1
    7198:	80 40       	sbci	r24, 0x00	; 0
    719a:	90 40       	sbci	r25, 0x00	; 0
    719c:	e1 f7       	brne	.-8      	; 0x7196 <main+0x1c>
    719e:	00 c0       	rjmp	.+0      	; 0x71a0 <main+0x26>
    71a0:	00 00       	nop
	_delay_ms(500);
	
	if (MCUSR & _BV(WDRF))
    71a2:	04 b6       	in	r0, 0x34	; 52
    71a4:	03 fe       	sbrs	r0, 3
    71a6:	07 c0       	rjmp	.+14     	; 0x71b6 <main+0x3c>
	{
		MCUSR = 0x00;
    71a8:	14 be       	out	0x34, r1	; 52
		start();
    71aa:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <__data_end>
    71ae:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <__data_end+0x1>
    71b2:	09 95       	icall
    71b4:	08 c0       	rjmp	.+16     	; 0x71c6 <main+0x4c>
void wdt_disable (void)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    71b6:	0f b6       	in	r0, 0x3f	; 63
    71b8:	f8 94       	cli
    71ba:	a8 95       	wdr
    71bc:	81 b5       	in	r24, 0x21	; 33
    71be:	88 61       	ori	r24, 0x18	; 24
    71c0:	81 bd       	out	0x21, r24	; 33
    71c2:	11 bc       	out	0x21, r1	; 33
    71c4:	0f be       	out	0x3f, r0	; 63
	hex_type = 0,
	/* empfangene HEX-Checksumme */
	hex_checksum=0;
	
	/* Füllen der Puffer mit definierten Werten */
	memset(hex_buffer, 0x00, sizeof(hex_buffer));
    71c6:	fe 01       	movw	r30, r28
    71c8:	ef 57       	subi	r30, 0x7F	; 127
    71ca:	ff 4f       	sbci	r31, 0xFF	; 255
    71cc:	85 e0       	ldi	r24, 0x05	; 5
    71ce:	df 01       	movw	r26, r30
    71d0:	1d 92       	st	X+, r1
    71d2:	8a 95       	dec	r24
    71d4:	e9 f7       	brne	.-6      	; 0x71d0 <main+0x56>
	memset(flash_data, 0xFF, sizeof(flash_data));
    71d6:	40 e8       	ldi	r20, 0x80	; 128
    71d8:	50 e0       	ldi	r21, 0x00	; 0
    71da:	6f ef       	ldi	r22, 0xFF	; 255
    71dc:	70 e0       	ldi	r23, 0x00	; 0
    71de:	ce 01       	movw	r24, r28
    71e0:	01 96       	adiw	r24, 0x01	; 1
    71e2:	0e 94 48 3b 	call	0x7690	; 0x7690 <memset>
	
	/* Interrupt Vektoren verbiegen */
	temp = GICR;
    71e6:	8b b7       	in	r24, 0x3b	; 59
	GICR = temp | (1<<IVCE);
    71e8:	98 2f       	mov	r25, r24
    71ea:	91 60       	ori	r25, 0x01	; 1
    71ec:	9b bf       	out	0x3b, r25	; 59
	GICR = temp | (1<<IVSEL);
    71ee:	82 60       	ori	r24, 0x02	; 2
    71f0:	8b bf       	out	0x3b, r24	; 59
	
	/* Einstellen der Baudrate und aktivieren der Interrupts */
	uart_init( UART_BAUD_SELECT(BOOT_UART_BAUD_RATE,F_CPU) );
    71f2:	83 e3       	ldi	r24, 0x33	; 51
    71f4:	90 e0       	ldi	r25, 0x00	; 0
    71f6:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <uart_init>
	sei();
    71fa:	78 94       	sei
	
	uart_puts("\n\r**********************************\n\r"	);
    71fc:	80 e6       	ldi	r24, 0x60	; 96
    71fe:	90 e0       	ldi	r25, 0x00	; 0
    7200:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
	uart_puts("* J.H Elec - Booty Ver.:1.0.0.0918\n\r"		);
    7204:	87 e8       	ldi	r24, 0x87	; 135
    7206:	90 e0       	ldi	r25, 0x00	; 0
    7208:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
	uart_puts("* press \"p\" for flash!\n\r"				);
    720c:	8c ea       	ldi	r24, 0xAC	; 172
    720e:	90 e0       	ldi	r25, 0x00	; 0
    7210:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
	uart_puts("* note: enable XON/OFF\n\r"					);
    7214:	85 ec       	ldi	r24, 0xC5	; 197
    7216:	90 e0       	ldi	r25, 0x00	; 0
    7218:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
	uart_puts("**********************************\n\n\r"	);
    721c:	8e ed       	ldi	r24, 0xDE	; 222
    721e:	90 e0       	ldi	r25, 0x00	; 0
    7220:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
    7224:	bf ef       	ldi	r27, 0xFF	; 255
    7226:	23 ed       	ldi	r18, 0xD3	; 211
    7228:	80 e3       	ldi	r24, 0x30	; 48
    722a:	b1 50       	subi	r27, 0x01	; 1
    722c:	20 40       	sbci	r18, 0x00	; 0
    722e:	80 40       	sbci	r24, 0x00	; 0
    7230:	e1 f7       	brne	.-8      	; 0x722a <main+0xb0>
    7232:	00 c0       	rjmp	.+0      	; 0x7234 <main+0xba>
    7234:	00 00       	nop
	/* Intel-HEX Datenlänge */
	hex_size = 0,
	/* Zähler für die empfangenen HEX-Daten einer Zeile */
	hex_data_cnt = 0,
	/* Intel-HEX Recordtype */
	hex_type = 0,
    7236:	ca 57       	subi	r28, 0x7A	; 122
    7238:	df 4f       	sbci	r29, 0xFF	; 255
    723a:	18 82       	st	Y, r1
    723c:	c6 58       	subi	r28, 0x86	; 134
    723e:	d0 40       	sbci	r29, 0x00	; 0
	/* Puffer für die Umwandlung der ASCII in Binärdaten */
	hex_buffer[5],
	/* Intel-HEX Datenlänge */
	hex_size = 0,
	/* Zähler für die empfangenen HEX-Daten einer Zeile */
	hex_data_cnt = 0,
    7240:	61 2c       	mov	r6, r1
	/* Position zum Schreiben in den HEX-Puffer */
	hex_cnt = 0,
	/* Puffer für die Umwandlung der ASCII in Binärdaten */
	hex_buffer[5],
	/* Intel-HEX Datenlänge */
	hex_size = 0,
    7242:	21 2c       	mov	r2, r1
	/* Flag zum ermitteln einer neuen Flash-Page */
	flash_page_flag = 1,
	/* Datenpuffer für die Hexdaten*/
	flash_data[SPM_PAGESIZE],
	/* Position zum Schreiben in den HEX-Puffer */
	hex_cnt = 0,
    7244:	10 e0       	ldi	r17, 0x00	; 0
	/* Flag zum steuern des Programmiermodus */
	boot_state = BOOT_STATE_EXIT,
	/* Empfangszustandssteuerung */
	parser_state = PARSER_STATE_START,
	/* Flag zum ermitteln einer neuen Flash-Page */
	flash_page_flag = 1,
    7246:	33 24       	eor	r3, r3
    7248:	33 94       	inc	r3
	/* temporäre Variable */
	uint8_t         temp,
	/* Flag zum steuern des Programmiermodus */
	boot_state = BOOT_STATE_EXIT,
	/* Empfangszustandssteuerung */
	parser_state = PARSER_STATE_START,
    724a:	00 e0       	ldi	r16, 0x00	; 0
	/* Positions zum Schreiben in der Datenpuffer */
	flash_cnt = 0;
	/* temporäre Variable */
	uint8_t         temp,
	/* Flag zum steuern des Programmiermodus */
	boot_state = BOOT_STATE_EXIT,
    724c:	51 2c       	mov	r5, r1
	/* Zu schreibende Flash-Page */
	flash_page = 0,
	/* Intel-HEX Checksumme zum Überprüfen des Daten */
	hex_check = 0,
	/* Positions zum Schreiben in der Datenpuffer */
	flash_cnt = 0;
    724e:	a1 2c       	mov	r10, r1
    7250:	b1 2c       	mov	r11, r1
	/* Intel-HEX Zieladresse */
	hex_addr = 0,
	/* Zu schreibende Flash-Page */
	flash_page = 0,
	/* Intel-HEX Checksumme zum Überprüfen des Daten */
	hex_check = 0,
    7252:	e1 2c       	mov	r14, r1
    7254:	f1 2c       	mov	r15, r1
	/* Empfangenes Zeichen + Statuscode */
	uint16_t        c = 0,
	/* Intel-HEX Zieladresse */
	hex_addr = 0,
	/* Zu schreibende Flash-Page */
	flash_page = 0,
    7256:	81 2c       	mov	r8, r1
    7258:	91 2c       	mov	r9, r1
/* Funktionspointer auf 0x0000 */
void (*start)( void ) = (void*)0x0000;


int main()
{
    725a:	44 24       	eor	r4, r4
    725c:	43 94       	inc	r4
							_delay_ms(100);
							program_page((uint16_t)flash_page, flash_data);
							boot_state = BOOT_STATE_EXIT;
						}
						/* Überprüfe Checksumme -> muss '0' sein */
						if(hex_check == 0) parser_state = PARSER_STATE_START;
    725e:	71 2c       	mov	r7, r1
	uart_puts("**********************************\n\n\r"	);
	_delay_ms(1000);
	
	do
	{
		c = uart_getc();
    7260:	0e 94 09 3b 	call	0x7612	; 0x7612 <uart_getc>
    7264:	6c 01       	movw	r12, r24
		if( !(c & UART_NO_DATA) )
    7266:	90 fd       	sbrc	r25, 0
    7268:	46 c1       	rjmp	.+652    	; 0x74f6 <main+0x37c>
		{
			/* Programmzustand: Parser */
			if(boot_state == BOOT_STATE_PARSER)
    726a:	91 e0       	ldi	r25, 0x01	; 1
    726c:	59 12       	cpse	r5, r25
    726e:	21 c1       	rjmp	.+578    	; 0x74b2 <main+0x338>
			{
				switch(parser_state)
    7270:	80 2f       	mov	r24, r16
    7272:	90 e0       	ldi	r25, 0x00	; 0
    7274:	87 30       	cpi	r24, 0x07	; 7
    7276:	91 05       	cpc	r25, r1
    7278:	08 f0       	brcs	.+2      	; 0x727c <main+0x102>
    727a:	3d c1       	rjmp	.+634    	; 0x74f6 <main+0x37c>
    727c:	fc 01       	movw	r30, r24
    727e:	e6 5d       	subi	r30, 0xD6	; 214
    7280:	f7 4c       	sbci	r31, 0xC7	; 199
    7282:	0c 94 42 3b 	jmp	0x7684	; 0x7684 <__tablejump2__>
				{
					/* Warte auf Zeilen-Startzeichen */
					case PARSER_STATE_START:
					if((uint8_t)c == START_SIGN)
    7286:	aa e3       	ldi	r26, 0x3A	; 58
    7288:	ca 12       	cpse	r12, r26
    728a:	5c c1       	rjmp	.+696    	; 0x7544 <main+0x3ca>
					{
						uart_putc(XOFF);
    728c:	83 e1       	ldi	r24, 0x13	; 19
    728e:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						parser_state = PARSER_STATE_SIZE;
						hex_cnt = 0;
						hex_check = 0;
						uart_putc(XON);
    7292:	81 e1       	ldi	r24, 0x11	; 17
    7294:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					case PARSER_STATE_START:
					if((uint8_t)c == START_SIGN)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_SIZE;
						hex_cnt = 0;
    7298:	17 2d       	mov	r17, r7
					/* Warte auf Zeilen-Startzeichen */
					case PARSER_STATE_START:
					if((uint8_t)c == START_SIGN)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_SIZE;
    729a:	04 2d       	mov	r16, r4
						hex_cnt = 0;
						hex_check = 0;
    729c:	e1 2c       	mov	r14, r1
    729e:	f1 2c       	mov	r15, r1
    72a0:	51 c1       	rjmp	.+674    	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Datengröße */
					case PARSER_STATE_SIZE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    72a2:	81 e0       	ldi	r24, 0x01	; 1
    72a4:	81 0f       	add	r24, r17
    72a6:	e1 e8       	ldi	r30, 0x81	; 129
    72a8:	f0 e0       	ldi	r31, 0x00	; 0
    72aa:	ec 0f       	add	r30, r28
    72ac:	fd 1f       	adc	r31, r29
    72ae:	e1 0f       	add	r30, r17
    72b0:	f1 1d       	adc	r31, r1
    72b2:	c0 82       	st	Z, r12
					if(hex_cnt == 2)
    72b4:	82 30       	cpi	r24, 0x02	; 2
    72b6:	09 f0       	breq	.+2      	; 0x72ba <main+0x140>
    72b8:	3c c1       	rjmp	.+632    	; 0x7532 <main+0x3b8>
					{
						uart_putc(XOFF);
    72ba:	83 e1       	ldi	r24, 0x13	; 19
    72bc:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						parser_state = PARSER_STATE_ADDRESS;
						hex_cnt = 0;
						hex_size = (uint8_t)hex2num(hex_buffer, 2);
    72c0:	62 e0       	ldi	r22, 0x02	; 2
    72c2:	ce 01       	movw	r24, r28
    72c4:	8f 57       	subi	r24, 0x7F	; 127
    72c6:	9f 4f       	sbci	r25, 0xFF	; 255
    72c8:	0e 94 50 38 	call	0x70a0	; 0x70a0 <hex2num>
    72cc:	28 2e       	mov	r2, r24
						hex_check += hex_size;
    72ce:	e8 0e       	add	r14, r24
    72d0:	f1 1c       	adc	r15, r1
						uart_putc(XON);
    72d2:	81 e1       	ldi	r24, 0x11	; 17
    72d4:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 2)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_ADDRESS;
						hex_cnt = 0;
    72d8:	17 2d       	mov	r17, r7
					case PARSER_STATE_SIZE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 2)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_ADDRESS;
    72da:	02 e0       	ldi	r16, 0x02	; 2
    72dc:	33 c1       	rjmp	.+614    	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Zieladresse */
					case PARSER_STATE_ADDRESS:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    72de:	81 e0       	ldi	r24, 0x01	; 1
    72e0:	81 0f       	add	r24, r17
    72e2:	e1 e8       	ldi	r30, 0x81	; 129
    72e4:	f0 e0       	ldi	r31, 0x00	; 0
    72e6:	ec 0f       	add	r30, r28
    72e8:	fd 1f       	adc	r31, r29
    72ea:	e1 0f       	add	r30, r17
    72ec:	f1 1d       	adc	r31, r1
    72ee:	c0 82       	st	Z, r12
					if(hex_cnt == 4)
    72f0:	84 30       	cpi	r24, 0x04	; 4
    72f2:	09 f0       	breq	.+2      	; 0x72f6 <main+0x17c>
    72f4:	20 c1       	rjmp	.+576    	; 0x7536 <main+0x3bc>
					{
						uart_putc(XOFF);
    72f6:	83 e1       	ldi	r24, 0x13	; 19
    72f8:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						parser_state = PARSER_STATE_TYPE;
						hex_cnt = 0;
						hex_addr = hex2num(hex_buffer, 4);
    72fc:	64 e0       	ldi	r22, 0x04	; 4
    72fe:	ce 01       	movw	r24, r28
    7300:	8f 57       	subi	r24, 0x7F	; 127
    7302:	9f 4f       	sbci	r25, 0xFF	; 255
    7304:	0e 94 50 38 	call	0x70a0	; 0x70a0 <hex2num>
						hex_check += (uint8_t) hex_addr;
						hex_check += (uint8_t) (hex_addr >> 8);
    7308:	29 2f       	mov	r18, r25
    730a:	33 27       	eor	r19, r19
    730c:	28 0f       	add	r18, r24
    730e:	31 1d       	adc	r19, r1
    7310:	e2 0e       	add	r14, r18
    7312:	f3 1e       	adc	r15, r19
						if(flash_page_flag)
    7314:	33 20       	and	r3, r3
    7316:	19 f0       	breq	.+6      	; 0x731e <main+0x1a4>
						{
							flash_page = hex_addr - hex_addr % SPM_PAGESIZE;
    7318:	4c 01       	movw	r8, r24
    731a:	b0 e8       	ldi	r27, 0x80	; 128
    731c:	8b 22       	and	r8, r27
							flash_page_flag = 0;
						}
						uart_putc(XON);
    731e:	81 e1       	ldi	r24, 0x11	; 17
    7320:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 4)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_TYPE;
						hex_cnt = 0;
    7324:	17 2d       	mov	r17, r7
						if(flash_page_flag)
						{
							flash_page = hex_addr - hex_addr % SPM_PAGESIZE;
							flash_page_flag = 0;
						}
						uart_putc(XON);
    7326:	37 2c       	mov	r3, r7
					case PARSER_STATE_ADDRESS:
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 4)
					{
						uart_putc(XOFF);
						parser_state = PARSER_STATE_TYPE;
    7328:	03 e0       	ldi	r16, 0x03	; 3
    732a:	0c c1       	rjmp	.+536    	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Zeilentyp */
					case PARSER_STATE_TYPE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    732c:	81 e0       	ldi	r24, 0x01	; 1
    732e:	81 0f       	add	r24, r17
    7330:	e1 e8       	ldi	r30, 0x81	; 129
    7332:	f0 e0       	ldi	r31, 0x00	; 0
    7334:	ec 0f       	add	r30, r28
    7336:	fd 1f       	adc	r31, r29
    7338:	e1 0f       	add	r30, r17
    733a:	f1 1d       	adc	r31, r1
    733c:	c0 82       	st	Z, r12
					if(hex_cnt == 2)
    733e:	82 30       	cpi	r24, 0x02	; 2
    7340:	09 f0       	breq	.+2      	; 0x7344 <main+0x1ca>
    7342:	fb c0       	rjmp	.+502    	; 0x753a <main+0x3c0>
					{
						uart_putc(XOFF);
    7344:	83 e1       	ldi	r24, 0x13	; 19
    7346:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						hex_cnt = 0;
						hex_data_cnt = 0;
						hex_type = (uint8_t)hex2num(hex_buffer, 2);
    734a:	62 e0       	ldi	r22, 0x02	; 2
    734c:	ce 01       	movw	r24, r28
    734e:	8f 57       	subi	r24, 0x7F	; 127
    7350:	9f 4f       	sbci	r25, 0xFF	; 255
    7352:	0e 94 50 38 	call	0x70a0	; 0x70a0 <hex2num>
    7356:	ca 57       	subi	r28, 0x7A	; 122
    7358:	df 4f       	sbci	r29, 0xFF	; 255
    735a:	88 83       	st	Y, r24
    735c:	c6 58       	subi	r28, 0x86	; 134
    735e:	d0 40       	sbci	r29, 0x00	; 0
    7360:	99 27       	eor	r25, r25
						hex_check += hex_type;
    7362:	e8 0e       	add	r14, r24
    7364:	f9 1e       	adc	r15, r25
						switch(hex_type)
    7366:	01 97       	sbiw	r24, 0x01	; 1
    7368:	11 f4       	brne	.+4      	; 0x736e <main+0x1f4>
						{
							case 0: parser_state = PARSER_STATE_DATA; break;
							case 1: parser_state = PARSER_STATE_CHECKSUM; break;
    736a:	05 e0       	ldi	r16, 0x05	; 5
    736c:	01 c0       	rjmp	.+2      	; 0x7370 <main+0x1f6>
						hex_data_cnt = 0;
						hex_type = (uint8_t)hex2num(hex_buffer, 2);
						hex_check += hex_type;
						switch(hex_type)
						{
							case 0: parser_state = PARSER_STATE_DATA; break;
    736e:	04 e0       	ldi	r16, 0x04	; 4
							case 1: parser_state = PARSER_STATE_CHECKSUM; break;
							default: parser_state = PARSER_STATE_DATA; break;
						}
						uart_putc(XON);
    7370:	81 e1       	ldi	r24, 0x11	; 17
    7372:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 2)
					{
						uart_putc(XOFF);
						hex_cnt = 0;
						hex_data_cnt = 0;
    7376:	61 2c       	mov	r6, r1
					case PARSER_STATE_TYPE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
					if(hex_cnt == 2)
					{
						uart_putc(XOFF);
						hex_cnt = 0;
    7378:	17 2d       	mov	r17, r7
    737a:	e4 c0       	rjmp	.+456    	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Flash-Daten */
					case PARSER_STATE_DATA:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    737c:	81 e0       	ldi	r24, 0x01	; 1
    737e:	81 0f       	add	r24, r17
    7380:	e1 e8       	ldi	r30, 0x81	; 129
    7382:	f0 e0       	ldi	r31, 0x00	; 0
    7384:	ec 0f       	add	r30, r28
    7386:	fd 1f       	adc	r31, r29
    7388:	e1 0f       	add	r30, r17
    738a:	f1 1d       	adc	r31, r1
    738c:	c0 82       	st	Z, r12
					if(hex_cnt == 2)
    738e:	82 30       	cpi	r24, 0x02	; 2
    7390:	09 f0       	breq	.+2      	; 0x7394 <main+0x21a>
    7392:	d5 c0       	rjmp	.+426    	; 0x753e <main+0x3c4>
					{
						uart_putc(XOFF);
    7394:	83 e1       	ldi	r24, 0x13	; 19
    7396:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						uart_putc('.');
    739a:	8e e2       	ldi	r24, 0x2E	; 46
    739c:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						hex_cnt = 0;
						flash_data[flash_cnt] = (uint8_t)hex2num(hex_buffer, 2);
    73a0:	62 e0       	ldi	r22, 0x02	; 2
    73a2:	ce 01       	movw	r24, r28
    73a4:	8f 57       	subi	r24, 0x7F	; 127
    73a6:	9f 4f       	sbci	r25, 0xFF	; 255
    73a8:	0e 94 50 38 	call	0x70a0	; 0x70a0 <hex2num>
    73ac:	e1 e0       	ldi	r30, 0x01	; 1
    73ae:	f0 e0       	ldi	r31, 0x00	; 0
    73b0:	ec 0f       	add	r30, r28
    73b2:	fd 1f       	adc	r31, r29
    73b4:	ea 0d       	add	r30, r10
    73b6:	fb 1d       	adc	r31, r11
    73b8:	80 83       	st	Z, r24
						hex_check += flash_data[flash_cnt];
    73ba:	e8 0e       	add	r14, r24
    73bc:	f1 1c       	adc	r15, r1
						flash_cnt++;
    73be:	2f ef       	ldi	r18, 0xFF	; 255
    73c0:	a2 1a       	sub	r10, r18
    73c2:	b2 0a       	sbc	r11, r18
						hex_data_cnt++;
    73c4:	63 94       	inc	r6
						if(hex_data_cnt == hex_size)
    73c6:	26 10       	cpse	r2, r6
    73c8:	02 c0       	rjmp	.+4      	; 0x73ce <main+0x254>
						{
							parser_state = PARSER_STATE_CHECKSUM;
							hex_data_cnt=0;
    73ca:	61 2c       	mov	r6, r1
						hex_check += flash_data[flash_cnt];
						flash_cnt++;
						hex_data_cnt++;
						if(hex_data_cnt == hex_size)
						{
							parser_state = PARSER_STATE_CHECKSUM;
    73cc:	05 e0       	ldi	r16, 0x05	; 5
							hex_data_cnt=0;
							hex_cnt = 0;
						}
						/* Puffer voll -> schreibe Page */
						if(flash_cnt == SPM_PAGESIZE)
    73ce:	80 e8       	ldi	r24, 0x80	; 128
    73d0:	a8 16       	cp	r10, r24
    73d2:	b1 04       	cpc	r11, r1
    73d4:	11 f5       	brne	.+68     	; 0x741a <main+0x2a0>
						{
							uart_puts("P\n\r");
    73d6:	84 e0       	ldi	r24, 0x04	; 4
    73d8:	91 e0       	ldi	r25, 0x01	; 1
    73da:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
    73de:	9f ef       	ldi	r25, 0xFF	; 255
    73e0:	a1 ee       	ldi	r26, 0xE1	; 225
    73e2:	b4 e0       	ldi	r27, 0x04	; 4
    73e4:	91 50       	subi	r25, 0x01	; 1
    73e6:	a0 40       	sbci	r26, 0x00	; 0
    73e8:	b0 40       	sbci	r27, 0x00	; 0
    73ea:	e1 f7       	brne	.-8      	; 0x73e4 <main+0x26a>
    73ec:	00 c0       	rjmp	.+0      	; 0x73ee <main+0x274>
    73ee:	00 00       	nop
							_delay_ms(100);
							program_page((uint16_t)flash_page, flash_data);
    73f0:	c4 01       	movw	r24, r8
    73f2:	a0 e0       	ldi	r26, 0x00	; 0
    73f4:	b0 e0       	ldi	r27, 0x00	; 0
    73f6:	ae 01       	movw	r20, r28
    73f8:	4f 5f       	subi	r20, 0xFF	; 255
    73fa:	5f 4f       	sbci	r21, 0xFF	; 255
    73fc:	bc 01       	movw	r22, r24
    73fe:	cd 01       	movw	r24, r26
    7400:	0e 94 76 38 	call	0x70ec	; 0x70ec <program_page>
							memset(flash_data, 0xFF, sizeof(flash_data));
    7404:	40 e8       	ldi	r20, 0x80	; 128
    7406:	50 e0       	ldi	r21, 0x00	; 0
    7408:	6f ef       	ldi	r22, 0xFF	; 255
    740a:	70 e0       	ldi	r23, 0x00	; 0
    740c:	ce 01       	movw	r24, r28
    740e:	01 96       	adiw	r24, 0x01	; 1
    7410:	0e 94 48 3b 	call	0x7690	; 0x7690 <memset>
							flash_cnt = 0;
							flash_page_flag = 1;
    7414:	34 2c       	mov	r3, r4
						{
							uart_puts("P\n\r");
							_delay_ms(100);
							program_page((uint16_t)flash_page, flash_data);
							memset(flash_data, 0xFF, sizeof(flash_data));
							flash_cnt = 0;
    7416:	a1 2c       	mov	r10, r1
    7418:	b1 2c       	mov	r11, r1
							flash_page_flag = 1;
						}
						uart_putc(XON);
    741a:	81 e1       	ldi	r24, 0x11	; 17
    741c:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
    7420:	17 2d       	mov	r17, r7
    7422:	90 c0       	rjmp	.+288    	; 0x7544 <main+0x3ca>
					}
					break;
					/* Parse Checksumme */
					case PARSER_STATE_CHECKSUM:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    7424:	dd 24       	eor	r13, r13
    7426:	d3 94       	inc	r13
    7428:	d1 0e       	add	r13, r17
    742a:	e1 e8       	ldi	r30, 0x81	; 129
    742c:	f0 e0       	ldi	r31, 0x00	; 0
    742e:	ec 0f       	add	r30, r28
    7430:	fd 1f       	adc	r31, r29
    7432:	e1 0f       	add	r30, r17
    7434:	f1 1d       	adc	r31, r1
    7436:	c0 82       	st	Z, r12
					if(hex_cnt == 2)
    7438:	22 e0       	ldi	r18, 0x02	; 2
    743a:	d2 12       	cpse	r13, r18
    743c:	82 c0       	rjmp	.+260    	; 0x7542 <main+0x3c8>
					{
						uart_putc(XOFF);
    743e:	83 e1       	ldi	r24, 0x13	; 19
    7440:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						hex_checksum = (uint8_t)hex2num(hex_buffer, 2);
    7444:	62 e0       	ldi	r22, 0x02	; 2
    7446:	ce 01       	movw	r24, r28
    7448:	8f 57       	subi	r24, 0x7F	; 127
    744a:	9f 4f       	sbci	r25, 0xFF	; 255
    744c:	0e 94 50 38 	call	0x70a0	; 0x70a0 <hex2num>
						hex_check += hex_checksum;
    7450:	e8 0e       	add	r14, r24
    7452:	f1 1c       	adc	r15, r1
						hex_check &= 0x00FF;
    7454:	ff 24       	eor	r15, r15
						/* Dateiende -> schreibe Restdaten */
						if(hex_type == 1)
    7456:	ca 57       	subi	r28, 0x7A	; 122
    7458:	df 4f       	sbci	r29, 0xFF	; 255
    745a:	88 81       	ld	r24, Y
    745c:	c6 58       	subi	r28, 0x86	; 134
    745e:	d0 40       	sbci	r29, 0x00	; 0
    7460:	81 30       	cpi	r24, 0x01	; 1
    7462:	c1 f4       	brne	.+48     	; 0x7494 <main+0x31a>
						{
							uart_puts("P\n\r");
    7464:	84 e0       	ldi	r24, 0x04	; 4
    7466:	91 e0       	ldi	r25, 0x01	; 1
    7468:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
    746c:	9f ef       	ldi	r25, 0xFF	; 255
    746e:	a1 ee       	ldi	r26, 0xE1	; 225
    7470:	b4 e0       	ldi	r27, 0x04	; 4
    7472:	91 50       	subi	r25, 0x01	; 1
    7474:	a0 40       	sbci	r26, 0x00	; 0
    7476:	b0 40       	sbci	r27, 0x00	; 0
    7478:	e1 f7       	brne	.-8      	; 0x7472 <main+0x2f8>
    747a:	00 c0       	rjmp	.+0      	; 0x747c <main+0x302>
    747c:	00 00       	nop
							_delay_ms(100);
							program_page((uint16_t)flash_page, flash_data);
    747e:	c4 01       	movw	r24, r8
    7480:	a0 e0       	ldi	r26, 0x00	; 0
    7482:	b0 e0       	ldi	r27, 0x00	; 0
    7484:	ae 01       	movw	r20, r28
    7486:	4f 5f       	subi	r20, 0xFF	; 255
    7488:	5f 4f       	sbci	r21, 0xFF	; 255
    748a:	bc 01       	movw	r22, r24
    748c:	cd 01       	movw	r24, r26
    748e:	0e 94 76 38 	call	0x70ec	; 0x70ec <program_page>
							boot_state = BOOT_STATE_EXIT;
    7492:	57 2c       	mov	r5, r7
						}
						/* Überprüfe Checksumme -> muss '0' sein */
						if(hex_check == 0) parser_state = PARSER_STATE_START;
    7494:	e1 14       	cp	r14, r1
    7496:	f1 04       	cpc	r15, r1
    7498:	11 f0       	breq	.+4      	; 0x749e <main+0x324>
						else parser_state = PARSER_STATE_ERROR;
    749a:	06 e0       	ldi	r16, 0x06	; 6
    749c:	01 c0       	rjmp	.+2      	; 0x74a0 <main+0x326>
							_delay_ms(100);
							program_page((uint16_t)flash_page, flash_data);
							boot_state = BOOT_STATE_EXIT;
						}
						/* Überprüfe Checksumme -> muss '0' sein */
						if(hex_check == 0) parser_state = PARSER_STATE_START;
    749e:	07 2d       	mov	r16, r7
						else parser_state = PARSER_STATE_ERROR;
						uart_putc(XON);
    74a0:	81 e1       	ldi	r24, 0x11	; 17
    74a2:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
						uart_putc(XON);
					}
					break;
					/* Parse Checksumme */
					case PARSER_STATE_CHECKSUM:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    74a6:	1d 2d       	mov	r17, r13
    74a8:	26 c0       	rjmp	.+76     	; 0x74f6 <main+0x37c>
						uart_putc(XON);
					}
					break;
					/* Parserfehler (falsche Checksumme) */
					case PARSER_STATE_ERROR:
					uart_putc('#');
    74aa:	83 e2       	ldi	r24, 0x23	; 35
    74ac:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					break;
    74b0:	49 c0       	rjmp	.+146    	; 0x7544 <main+0x3ca>
				}
			}
			/* Programmzustand: UART Kommunikation */
			else if(boot_state != BOOT_STATE_PARSER)
			{
				switch((uint8_t)c)
    74b2:	c6 01       	movw	r24, r12
    74b4:	99 27       	eor	r25, r25
    74b6:	80 37       	cpi	r24, 0x70	; 112
    74b8:	91 05       	cpc	r25, r1
    74ba:	21 f0       	breq	.+8      	; 0x74c4 <main+0x34a>
    74bc:	81 37       	cpi	r24, 0x71	; 113
    74be:	91 05       	cpc	r25, r1
    74c0:	51 f0       	breq	.+20     	; 0x74d6 <main+0x35c>
    74c2:	0e c0       	rjmp	.+28     	; 0x74e0 <main+0x366>
				{
					case 'p':
					boot_state = BOOT_STATE_PARSER;
					uart_puts("flash DevBoard!\n\r");
    74c4:	88 e0       	ldi	r24, 0x08	; 8
    74c6:	91 e0       	ldi	r25, 0x01	; 1
    74c8:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
					uart_puts("paste .hex\n\r");
    74cc:	8a e1       	ldi	r24, 0x1A	; 26
    74ce:	91 e0       	ldi	r25, 0x01	; 1
    74d0:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
					break;
    74d4:	37 c0       	rjmp	.+110    	; 0x7544 <main+0x3ca>
					case 'q':
					boot_state = BOOT_STATE_EXIT;
					uart_puts("exit booty!\n\r");
    74d6:	87 e2       	ldi	r24, 0x27	; 39
    74d8:	91 e0       	ldi	r25, 0x01	; 1
    74da:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
    74de:	0d c0       	rjmp	.+26     	; 0x74fa <main+0x380>
					break;
					default:
					uart_puts("echo: ");
    74e0:	85 e3       	ldi	r24, 0x35	; 53
    74e2:	91 e0       	ldi	r25, 0x01	; 1
    74e4:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
					uart_putc((unsigned char)c);
    74e8:	8c 2d       	mov	r24, r12
    74ea:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
					uart_puts("\n\r");
    74ee:	83 e5       	ldi	r24, 0x53	; 83
    74f0:	91 e0       	ldi	r25, 0x01	; 1
    74f2:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
					break;
				}
			}
		}
	}
	while(boot_state!=BOOT_STATE_EXIT);
    74f6:	51 10       	cpse	r5, r1
    74f8:	b3 ce       	rjmp	.-666    	; 0x7260 <main+0xe6>
	
	uart_puts("Starting Application!\n\n\n\r");
    74fa:	8c e3       	ldi	r24, 0x3C	; 60
    74fc:	91 e0       	ldi	r25, 0x01	; 1
    74fe:	0e 94 33 3b 	call	0x7666	; 0x7666 <uart_puts>
    7502:	2f ef       	ldi	r18, 0xFF	; 255
    7504:	85 ea       	ldi	r24, 0xA5	; 165
    7506:	9e e0       	ldi	r25, 0x0E	; 14
    7508:	21 50       	subi	r18, 0x01	; 1
    750a:	80 40       	sbci	r24, 0x00	; 0
    750c:	90 40       	sbci	r25, 0x00	; 0
    750e:	e1 f7       	brne	.-8      	; 0x7508 <main+0x38e>
    7510:	00 c0       	rjmp	.+0      	; 0x7512 <main+0x398>
    7512:	00 00       	nop

	_delay_ms(300);
	
	/* Interrupt Vektoren wieder gerade biegen */
	temp = GICR;
    7514:	8b b7       	in	r24, 0x3b	; 59
	GICR = temp | (1<<IVCE);
    7516:	98 2f       	mov	r25, r24
    7518:	91 60       	ori	r25, 0x01	; 1
    751a:	9b bf       	out	0x3b, r25	; 59
	GICR = temp & ~(1<<IVSEL);
    751c:	8d 7f       	andi	r24, 0xFD	; 253
    751e:	8b bf       	out	0x3b, r24	; 59
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
    7520:	98 e0       	ldi	r25, 0x08	; 8
    7522:	88 e1       	ldi	r24, 0x18	; 24
    7524:	0f b6       	in	r0, 0x3f	; 63
    7526:	f8 94       	cli
    7528:	a8 95       	wdr
    752a:	81 bd       	out	0x21, r24	; 33
    752c:	0f be       	out	0x3f, r0	; 63
    752e:	91 bd       	out	0x21, r25	; 33
    7530:	ff cf       	rjmp	.-2      	; 0x7530 <main+0x3b6>
						uart_putc(XON);
					}
					break;
					/* Parse Datengröße */
					case PARSER_STATE_SIZE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    7532:	18 2f       	mov	r17, r24
    7534:	07 c0       	rjmp	.+14     	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Zieladresse */
					case PARSER_STATE_ADDRESS:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    7536:	18 2f       	mov	r17, r24
    7538:	05 c0       	rjmp	.+10     	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Zeilentyp */
					case PARSER_STATE_TYPE:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    753a:	18 2f       	mov	r17, r24
    753c:	03 c0       	rjmp	.+6      	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Flash-Daten */
					case PARSER_STATE_DATA:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    753e:	18 2f       	mov	r17, r24
    7540:	01 c0       	rjmp	.+2      	; 0x7544 <main+0x3ca>
						uart_putc(XON);
					}
					break;
					/* Parse Checksumme */
					case PARSER_STATE_CHECKSUM:
					hex_buffer[hex_cnt++] = (uint8_t)c;
    7542:	1d 2d       	mov	r17, r13
/* Funktionspointer auf 0x0000 */
void (*start)( void ) = (void*)0x0000;


int main()
{
    7544:	54 2c       	mov	r5, r4
    7546:	8c ce       	rjmp	.-744    	; 0x7260 <main+0xe6>

00007548 <__vector_13>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    7548:	1f 92       	push	r1
    754a:	0f 92       	push	r0
    754c:	0f b6       	in	r0, 0x3f	; 63
    754e:	0f 92       	push	r0
    7550:	11 24       	eor	r1, r1
    7552:	2f 93       	push	r18
    7554:	8f 93       	push	r24
    7556:	9f 93       	push	r25
    7558:	ef 93       	push	r30
    755a:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    755c:	8b b1       	in	r24, 0x0b	; 11
    data = UART0_DATA;
    755e:	2c b1       	in	r18, 0x0c	; 12
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    7560:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    7562:	e0 91 5a 01 	lds	r30, 0x015A	; 0x80015a <UART_RxHead>
    7566:	ef 5f       	subi	r30, 0xFF	; 255
    7568:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART_RxTail ) {
    756a:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <UART_RxTail>
    756e:	e9 17       	cp	r30, r25
    7570:	39 f0       	breq	.+14     	; 0x7580 <__vector_13+0x38>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    7572:	e0 93 5a 01 	sts	0x015A, r30	; 0x80015a <UART_RxHead>
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    7576:	f0 e0       	ldi	r31, 0x00	; 0
    7578:	e3 5a       	subi	r30, 0xA3	; 163
    757a:	fe 4f       	sbci	r31, 0xFE	; 254
    757c:	20 83       	st	Z, r18
    757e:	01 c0       	rjmp	.+2      	; 0x7582 <__vector_13+0x3a>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    7580:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    7582:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <UART_LastRxError>
    7586:	89 2b       	or	r24, r25
    7588:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <UART_LastRxError>
}
    758c:	ff 91       	pop	r31
    758e:	ef 91       	pop	r30
    7590:	9f 91       	pop	r25
    7592:	8f 91       	pop	r24
    7594:	2f 91       	pop	r18
    7596:	0f 90       	pop	r0
    7598:	0f be       	out	0x3f, r0	; 63
    759a:	0f 90       	pop	r0
    759c:	1f 90       	pop	r1
    759e:	18 95       	reti

000075a0 <__vector_14>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    75a0:	1f 92       	push	r1
    75a2:	0f 92       	push	r0
    75a4:	0f b6       	in	r0, 0x3f	; 63
    75a6:	0f 92       	push	r0
    75a8:	11 24       	eor	r1, r1
    75aa:	8f 93       	push	r24
    75ac:	9f 93       	push	r25
    75ae:	ef 93       	push	r30
    75b0:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
    75b2:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <UART_TxHead>
    75b6:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <UART_TxTail>
    75ba:	98 17       	cp	r25, r24
    75bc:	61 f0       	breq	.+24     	; 0x75d6 <__vector_14+0x36>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    75be:	e0 91 5b 01 	lds	r30, 0x015B	; 0x80015b <UART_TxTail>
    75c2:	ef 5f       	subi	r30, 0xFF	; 255
    75c4:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
    75c6:	e0 93 5b 01 	sts	0x015B, r30	; 0x80015b <UART_TxTail>
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    75ca:	f0 e0       	ldi	r31, 0x00	; 0
    75cc:	e3 58       	subi	r30, 0x83	; 131
    75ce:	fe 4f       	sbci	r31, 0xFE	; 254
    75d0:	80 81       	ld	r24, Z
    75d2:	8c b9       	out	0x0c, r24	; 12
    75d4:	01 c0       	rjmp	.+2      	; 0x75d8 <__vector_14+0x38>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    75d6:	55 98       	cbi	0x0a, 5	; 10
    }
}
    75d8:	ff 91       	pop	r31
    75da:	ef 91       	pop	r30
    75dc:	9f 91       	pop	r25
    75de:	8f 91       	pop	r24
    75e0:	0f 90       	pop	r0
    75e2:	0f be       	out	0x3f, r0	; 63
    75e4:	0f 90       	pop	r0
    75e6:	1f 90       	pop	r1
    75e8:	18 95       	reti

000075ea <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    75ea:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <UART_TxHead>
    UART_TxTail = 0;
    75ee:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <UART_TxTail>
    UART_RxHead = 0;
    75f2:	10 92 5a 01 	sts	0x015A, r1	; 0x80015a <UART_RxHead>
    UART_RxTail = 0;
    75f6:	10 92 59 01 	sts	0x0159, r1	; 0x800159 <UART_RxTail>
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    75fa:	99 23       	and	r25, r25
    75fc:	1c f4       	brge	.+6      	; 0x7604 <uart_init+0x1a>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    75fe:	22 e0       	ldi	r18, 0x02	; 2
    7600:	2b b9       	out	0x0b, r18	; 11
    	 baudrate &= ~0x8000;
    7602:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    7604:	90 bd       	out	0x20, r25	; 32
    UBRRL = (unsigned char) baudrate;
    7606:	89 b9       	out	0x09, r24	; 9
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    7608:	88 e9       	ldi	r24, 0x98	; 152
    760a:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    760c:	86 e8       	ldi	r24, 0x86	; 134
    760e:	80 bd       	out	0x20, r24	; 32
    7610:	08 95       	ret

00007612 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    7612:	90 91 5a 01 	lds	r25, 0x015A	; 0x80015a <UART_RxHead>
    7616:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <UART_RxTail>
    761a:	98 17       	cp	r25, r24
    761c:	81 f0       	breq	.+32     	; 0x763e <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    761e:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <UART_RxTail>
    7622:	ef 5f       	subi	r30, 0xFF	; 255
    7624:	ef 71       	andi	r30, 0x1F	; 31
    UART_RxTail = tmptail; 
    7626:	e0 93 59 01 	sts	0x0159, r30	; 0x800159 <UART_RxTail>
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    762a:	f0 e0       	ldi	r31, 0x00	; 0
    762c:	e3 5a       	subi	r30, 0xA3	; 163
    762e:	fe 4f       	sbci	r31, 0xFE	; 254
    7630:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
    7632:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <UART_LastRxError>
    UART_LastRxError = 0;
    7636:	10 92 58 01 	sts	0x0158, r1	; 0x800158 <UART_LastRxError>
    return data;
    763a:	90 e0       	ldi	r25, 0x00	; 0
    763c:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    763e:	80 e0       	ldi	r24, 0x00	; 0
    7640:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
    7642:	08 95       	ret

00007644 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    7644:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <UART_TxHead>
    7648:	2f 5f       	subi	r18, 0xFF	; 255
    764a:	2f 71       	andi	r18, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
    764c:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <UART_TxTail>
    7650:	29 17       	cp	r18, r25
    7652:	e1 f3       	breq	.-8      	; 0x764c <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    7654:	e2 2f       	mov	r30, r18
    7656:	f0 e0       	ldi	r31, 0x00	; 0
    7658:	e3 58       	subi	r30, 0x83	; 131
    765a:	fe 4f       	sbci	r31, 0xFE	; 254
    765c:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    765e:	20 93 5c 01 	sts	0x015C, r18	; 0x80015c <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    7662:	55 9a       	sbi	0x0a, 5	; 10
    7664:	08 95       	ret

00007666 <uart_puts>:
Purpose:  transmit string to UART
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    7666:	cf 93       	push	r28
    7668:	df 93       	push	r29
    766a:	ec 01       	movw	r28, r24
    while (*s) 
    766c:	88 81       	ld	r24, Y
    766e:	88 23       	and	r24, r24
    7670:	31 f0       	breq	.+12     	; 0x767e <uart_puts+0x18>
    7672:	21 96       	adiw	r28, 0x01	; 1
      uart_putc(*s++);
    7674:	0e 94 22 3b 	call	0x7644	; 0x7644 <uart_putc>
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
    7678:	89 91       	ld	r24, Y+
    767a:	81 11       	cpse	r24, r1
    767c:	fb cf       	rjmp	.-10     	; 0x7674 <uart_puts+0xe>
      uart_putc(*s++);

}/* uart_puts */
    767e:	df 91       	pop	r29
    7680:	cf 91       	pop	r28
    7682:	08 95       	ret

00007684 <__tablejump2__>:
    7684:	ee 0f       	add	r30, r30
    7686:	ff 1f       	adc	r31, r31
    7688:	05 90       	lpm	r0, Z+
    768a:	f4 91       	lpm	r31, Z
    768c:	e0 2d       	mov	r30, r0
    768e:	09 94       	ijmp

00007690 <memset>:
    7690:	dc 01       	movw	r26, r24
    7692:	01 c0       	rjmp	.+2      	; 0x7696 <memset+0x6>
    7694:	6d 93       	st	X+, r22
    7696:	41 50       	subi	r20, 0x01	; 1
    7698:	50 40       	sbci	r21, 0x00	; 0
    769a:	e0 f7       	brcc	.-8      	; 0x7694 <memset+0x4>
    769c:	08 95       	ret

0000769e <_exit>:
    769e:	f8 94       	cli

000076a0 <__stop_program>:
    76a0:	ff cf       	rjmp	.-2      	; 0x76a0 <__stop_program>
